//длина Initialization vectorprivate static final int GCM_IV_LENGTH = 12;//длина тегаprivate static final int GCM_TAG_LENGTH = 16;//алгоритмprivate static final String CIPHER_ALGORITHM = "AES/GCM/NoPadding"; public String decrypt(                         //строка, которая приходит в запросе от RuStore                        String encryptedInput,                        //ключ, который копируем из консоли                        String secretKey) {    try {        //декодируем входящее ecrypt сообщение        byte[] decoded = Base64.getDecoder().decode(encryptedInput.getBytes(StandardCharsets.UTF_8));        //выделяем вектор из последовательности байт        byte[] ivDecrypt = Arrays.copyOfRange(decoded, 0, GCM_IV_LENGTH);        //инициализируем объект параметров GCM        GCMParameterSpec ivSpec = new GCMParameterSpec(GCM_TAG_LENGTH * Byte.SIZE, ivDecrypt);        //получаем инстанс объекта по алгоритму шифрования        Cipher cipher = Cipher.getInstance(CIPHER_ALGORITHM);        //инициализируем объект шифрования в режиме decrypt, ключом и вектором        cipher.init(Cipher.DECRYPT_MODE, convertStringToSecretKey(secretKey), ivSpec);        //дешифруем набор байт начиная с окончания вектора        byte[] ciphertext = cipher.doFinal(decoded, GCM_IV_LENGTH, decoded.length - GCM_IV_LENGTH);        //возвращаем ответ в формате String UTF_8        return new String(ciphertext, StandardCharsets.UTF_8);    } catch (Exception e) {        //в случае ошибки логируем проблему        logger.warn("Something went wrong with decrypting", e);        throw new RuntimeException(e);    }} //десериализуем ключ из текстового формата Base64(UTF_8) в объект SecretKeyprivate SecretKey convertStringToSecretKey(String secretKey) {    byte[] decodedKey = Base64.getDecoder().decode(secretKey.getBytes(StandardCharsets.UTF_8));    return new SecretKeySpec(decodedKey, 0, decodedKey.length, "AES");}